#!/usr/bin/env node
// build.mjs
// This script performs the following steps:
// 1. Uses `cargo metadata` to extract package metadata.
// 2. Constructs a detailed package.json using that metadata.
// 3. Invokes `cargo build --target wasm32-unknown-unknown` for the local package.
// 4. Locates the wasm artifact (by searching upward for the target directory),
//    and runs wasm-bindgen (with --target web, --omit-imports, --omit-default-module-path)
//    outputting the JS bindings into a pkg directory.
// 5. Generates an inline loader script that embeds the wasm as a base64 string.
// 6. Publishes the package (unless the `--dry-run` CLI argument is present).

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

const isDryRun = process.argv.includes('--dry-run');

async function main() {
  // 1. Extract package metadata using cargo metadata.
  console.log("Extracting package metadata via cargo metadata...");
  const metadataJson = execSync('cargo metadata --no-deps --format-version 1', { encoding: 'utf-8' });
  const metadata = JSON.parse(metadataJson);
  const manifestPath = path.resolve('Cargo.toml');
  const pkgMeta = metadata.packages.find(pkg => path.resolve(pkg.manifest_path) === manifestPath);
  if (!pkgMeta) {
    throw new Error("Could not find package metadata for the current Cargo.toml");
  }
  const pkgName = pkgMeta.name;
  const pkgVersion = pkgMeta.version;
  const pkgDescription = pkgMeta.description || "";
  const pkgLicense = pkgMeta.license || "";
  const pkgHomepage = pkgMeta.homepage || "";
  const pkgRepository = pkgMeta.repository || "";
  const pkgKeywords = pkgMeta.keywords || [];
  // We'll use authors as collaborators.
  const pkgCollaborators = pkgMeta.authors || [];

  // Convert crate name to snake_case for file naming (dashes become underscores).
  const pkgBaseName = pkgName.replace(/-/g, '_');
  // wasm-bindgen will output files named like `<pkgBaseName>.js` and `<pkgBaseName>_bg.wasm`
  const wasmBindgenJs = `${pkgBaseName}.js`;
  const wasmBindgenWasm = `${pkgBaseName}_bg.wasm`;
  const wasmBindgenDts = `${pkgBaseName}.d.ts`;

  // 2. Build the Rust crate for the wasm target.
  console.log("Building the Rust project with cargo...");
  execSync('cargo build --target wasm32-unknown-unknown', { stdio: 'inherit' });

  // 3. Locate the target directory by searching upward from the current directory.
  let targetDir = null;
  let currentDir = process.cwd();
  while (currentDir !== path.parse(currentDir).root) {
    const potentialTarget = path.join(currentDir, 'target');
    if (fs.existsSync(potentialTarget)) {
      targetDir = potentialTarget;
      break;
    }
    currentDir = path.dirname(currentDir);
  }
  if (!targetDir) {
    throw new Error("Could not locate the target directory");
  }
  // Assume a debug build; the wasm artifact should be at:
  //   target/wasm32-unknown-unknown/debug/<pkgBaseName>.wasm
  const wasmArtifactPath = path.join(targetDir, 'wasm32-unknown-unknown', 'debug', `${pkgBaseName}.wasm`);
  if (!fs.existsSync(wasmArtifactPath)) {
    throw new Error(`Wasm artifact not found at ${wasmArtifactPath}`);
  }

  // 4. Run wasm-bindgen on the artifact.
  console.log("Running wasm-bindgen...");
  const pkgDir = path.resolve('pkg');
  if (!fs.existsSync(pkgDir)) {
    fs.mkdirSync(pkgDir);
  }
  const wasmBindgenCmd = `wasm-bindgen ${wasmArtifactPath} --out-dir ${pkgDir} --target web --omit-imports --omit-default-module-path`;
  execSync(wasmBindgenCmd, { stdio: 'inherit' });

  // 5. Construct the inline loader.
  const wasmOutputPath = path.join(pkgDir, wasmBindgenWasm);
  if (!fs.existsSync(wasmOutputPath)) {
    throw new Error(`Wasm file not found in pkg directory: ${wasmOutputPath}`);
  }
  const wasmBuffer = fs.readFileSync(wasmOutputPath);
  const wasmBase64 = wasmBuffer.toString('base64');

  const inlineLoaderContent = `
// This file is auto-generated by build.mjs.
// It inlines the wasm module as a base64 string and loads it synchronously.

import { initSync } from './${wasmBindgenJs}';

const base64Wasm = "${wasmBase64}";

// Convert a base64 string to a Uint8Array.
function base64ToUint8Array(base64) {
  if (typeof atob === 'function') {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  } else if (typeof Buffer === 'function') {
    return new Uint8Array(Buffer.from(base64, 'base64'));
  } else {
    throw new Error('No base64 decoder available');
  }
}

const wasmBytes = base64ToUint8Array(base64Wasm);

// Initialize the generated bindings with the inlined wasm instance.
initSync({ module: wasmBytes });

export * from './${wasmBindgenJs}';
`.trim();

  const inlineLoaderPath = path.join(pkgDir, 'index.js');
  fs.writeFileSync(inlineLoaderPath, inlineLoaderContent);
  console.log(`Generated inline loader: ${inlineLoaderPath}`);

  // 6. Construct a fleshed-out package.json.
  const packageJson = {
    name: pkgName,
    type: "module",
    collaborators: pkgCollaborators,
    description: pkgDescription,
    version: pkgVersion,
    license: pkgLicense,
    repository: pkgRepository ? { type: "git", url: pkgRepository } : undefined,
    files: [
      // With inlined wasm, ship the loader and generated JS bindings.
      "index.js",
      wasmBindgenJs,
      wasmBindgenDts
    ],
    main: "index.js",
    homepage: pkgHomepage,
    types: wasmBindgenDts,
    sideEffects: [
      "./snippets/*"
    ],
    keywords: pkgKeywords
  };

  // Remove any keys that are undefined.
  Object.keys(packageJson).forEach(key => {
    if (packageJson[key] === undefined) {
      delete packageJson[key];
    }
  });

  const pkgJsonPath = path.join(pkgDir, 'package.json');
  fs.writeFileSync(pkgJsonPath, JSON.stringify(packageJson, null, 2));
  console.log(`Updated package.json: ${pkgJsonPath}`);

  // 7. Publish the package unless --dry-run is provided.
  if (!isDryRun) {
    console.log("Publishing package...");
    execSync('npm publish', { stdio: 'inherit', cwd: pkgDir });
  } else {
    console.log("--dry-run flag present, skipping npm publish.");
  }

  console.log("Build complete: Wasm module inlined and package.json regenerated.");
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});

